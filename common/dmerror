##/bin/bash
# SPDX-License-Identifier: GPL-2.0
# Copyright (c) 2015 Oracle.  All Rights Reserved.
#
# common functions for setting up and tearing down a dmerror device

echo $MOUNT_OPTIONS | grep -q dax
if [ $? -eq 0 ]; then
	_notrun "Cannot run tests with DAX on dmerror devices"
fi

_dmerror_setup()
{
	local dm_backing_dev=$SCRATCH_DEV

	local blk_dev_size=`blockdev --getsz $dm_backing_dev`

	DMERROR_DEV='/dev/mapper/error-test'

	DMLINEAR_TABLE="0 $blk_dev_size linear $dm_backing_dev 0"

	DMERROR_TABLE="0 $blk_dev_size error $dm_backing_dev 0"
}

_dmerror_init()
{
	_dmerror_setup
	_dmsetup_remove error-test
	_dmsetup_create error-test --table "$DMLINEAR_TABLE" || \
		_fatal "failed to create dm linear device"
}

_dmerror_mount()
{
	_scratch_options mount
	$MOUNT_PROG -t $FSTYP `_common_dev_mount_options $*` $SCRATCH_OPTIONS \
		$DMERROR_DEV $SCRATCH_MNT
}

_dmerror_unmount()
{
	umount $SCRATCH_MNT
}

_dmerror_cleanup()
{
	$DMSETUP_PROG resume error-test > /dev/null 2>&1
	$UMOUNT_PROG $SCRATCH_MNT > /dev/null 2>&1
	_dmsetup_remove error-test
}

_dmerror_load_error_table()
{
	suspend_opt="--nolockfs"

	if [ "$1" = "lockfs" ]; then
		suspend_opt=""
	elif [ -n "$*" ]; then
		suspend_opt="$*"
	fi

	$DMSETUP_PROG suspend $suspend_opt error-test
	[ $? -ne 0 ] && _fail  "dmsetup suspend failed"

	echo "$DMERROR_TABLE" | $DMSETUP_PROG load error-test
	load_res=$?

	$DMSETUP_PROG resume error-test
	resume_res=$?

	[ $load_res -ne 0 ] && _fail "dmsetup failed to load error table"
	[ $resume_res -ne 0 ] && _fail  "dmsetup resume failed"
}

_dmerror_load_working_table()
{
	suspend_opt="--nolockfs"

	if [ "$1" = "lockfs" ]; then
		suspend_opt=""
	elif [ -n "$*" ]; then
		suspend_opt="$*"
	fi

	$DMSETUP_PROG suspend $suspend_opt error-test
	[ $? -ne 0 ] && _fail  "dmsetup suspend failed"

	$DMSETUP_PROG load error-test --table "$DMLINEAR_TABLE"
	load_res=$?

	$DMSETUP_PROG resume error-test
	resume_res=$?

	[ $load_res -ne 0 ] && _fail "dmsetup failed to load error table"
	[ $resume_res -ne 0 ] && _fail  "dmsetup resume failed"
}

# Given a list of (start, length) tuples on stdin, combine adjacent tuples into
# larger ones and write the new list to stdout.
__dmerror_combine_extents()
{
	awk 'BEGIN{start = 0; len = 0;}{
if (start + len == $1) {
	len += $2;
} else {
	if (len > 0)
		printf("%d %d\n", start, len);
	start = $1;
	len = $2;
}
} END {
	if (len > 0)
		printf("%d %d\n", start, len);
}'
}

# Given a block device, the name of a preferred dm target, the name of an
# implied dm target, and a list of (start, len) tuples on stdin, create a new
# dm table which maps each of the tuples to the preferred target and all other
# areas to the implied dm target.
__dmerror_recreate_map()
{
	local device="$1"
	local preferred_tgt="$2"
	local implied_tgt="$3"
	local size=$(blockdev --getsz "$device")

	awk -v device="$device" -v size=$size -v implied_tgt="$implied_tgt" \
		-v preferred_tgt="$preferred_tgt" 'BEGIN{implied_start = 0;}{
	extent_start = $1;
	extent_len = $2;

	if (extent_start > size) {
		extent_start = size;
		extent_len = 0;
	} else if (extent_start + extent_len > size) {
		extent_len = size - extent_start;
	}

	if (implied_start < extent_start)
		printf("%d %d %s %s %d\n", implied_start,
				extent_start - implied_start, implied_tgt,
				device, implied_start);
	printf("%d %d %s %s %d\n", extent_start, extent_len, preferred_tgt,
			device, extent_start);
	implied_start = extent_start + extent_len;
}END{
	if (implied_start < size)
		printf("%d %d %s %s %d\n", implied_start, size - implied_start,
				implied_tgt, device, implied_start);
}'
}

# Update the dm error table so that the range (start, len) maps to the
# preferred dm target, overriding anything that maps to the implied dm target.
# This assumes that the only desired targets for this dm device are the
# preferred and and implied targets.  The optional fifth argument can be used
# to change the underlying device.
__dmerror_change()
{
	local start="$1"
	local len="$2"
	local preferred_tgt="$3"
	local implied_tgt="$4"
	local dm_backing_dev="$5"
	test -z "$dm_backing_dev" && dm_backing_dev="$SCRATCH_DEV"

	DMERROR_TABLE="$( (echo "$DMERROR_TABLE"; echo "$start $len $preferred_tgt") | \
		awk -v type="$preferred_tgt" '{if ($3 == type) print $0;}' | \
		sort -g | \
		__dmerror_combine_extents | \
		__dmerror_recreate_map "$dm_backing_dev" "$preferred_tgt" \
				"$implied_tgt" )"
}

# Reset the dm error table to everything ok.  The dm device itself must be
# remapped by calling _dmerror_load_error_table.
_dmerror_reset_table()
{
	DMERROR_TABLE="$DMLINEAR_TABLE"
}

# Update the dm error table so that IOs to the given range will return EIO.
# The dm device itself must be remapped by calling _dmerror_load_error_table.
_dmerror_mark_range_bad()
{
	local start="$1"
	local len="$2"

	__dmerror_change "$start" "$len" error linear
}

# Update the dm error table so that IOs to the given range will succeed.
# The dm device itself must be remapped by calling _dmerror_load_error_table.
_dmerror_mark_range_good()
{
	local start="$1"
	local len="$2"

	__dmerror_change "$start" "$len" linear error
}
